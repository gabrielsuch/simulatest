/**
 * RmiJdbc client/server JDBC Driver
 * (C) GIE Dyade (Groupe BULL / INRIA Research Center) 1997
 * (C) ExperLog 1999-2000
 *
 * @version     1.0
 * @author      Pierre-Yves Gibello (pierreyves.gibello@experlog.com)
 */

package org.objectweb.rmijdbc;

import java.sql.*;
import java.rmi.RemoteException;

/**
 * <P>
 * A Statement object is used for executing a static SQL statement and obtaining
 * the results produced by it.
 * 
 * <P>
 * Only one ResultSet per Statement can be open at any point in time. Therefore,
 * if the reading of one ResultSet is interleaved with the reading of another,
 * each must have been generated by different Statements. All statement execute
 * methods implicitly close a statment's current ResultSet if an open one
 * exists.
 * 
 * @see Connection#createStatement
 * @see ResultSet
 */
public class RJStatement implements java.sql.Statement, java.io.Serializable {

	private static final long serialVersionUID = 4992684705455801640L;
	
	RJStatementInterface rmiStatement_;
	Connection connection_;

	public RJStatement(RJStatementInterface s, Connection c) {
		rmiStatement_ = s;
		connection_ = c;
	}

	/**
	 * Execute a SQL statement that returns a single ResultSet.
	 * 
	 * @param sql
	 *            typically this is a static SQL SELECT statement
	 * @return a ResultSet that contains the data produced by the query; never
	 *         null
	 */
	public java.sql.ResultSet executeQuery(String sql) throws SQLException {
		try {
			return new RJResultSet(rmiStatement_.executeQuery(sql), this);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Execute a SQL INSERT, UPDATE or DELETE statement. In addition, SQL
	 * statements that return nothing such as SQL DDL statements can be
	 * executed.
	 * 
	 * @param sql
	 *            a SQL INSERT, UPDATE or DELETE statement or a SQL statement
	 *            that returns nothing
	 * @return either the row count for INSERT, UPDATE or DELETE or 0 for SQL
	 *         statements that return nothing
	 */
	public int executeUpdate(String sql) throws SQLException {
		try {
			return rmiStatement_.executeUpdate(sql);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * In many cases, it is desirable to immediately release a Statements's
	 * database and JDBC resources instead of waiting for this to happen when it
	 * is automatically closed; the close method provides this immediate
	 * release.
	 * 
	 * <P>
	 * <B>Note:</B> A Statement is automatically closed when it is garbage
	 * collected. When a Statement is closed, its current ResultSet, if one
	 * exists, is also closed.
	 */
	public void close() throws SQLException {
		try {
			rmiStatement_.close();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// ----------------------------------------------------------------------

	/**
	 * The maxFieldSize limit (in bytes) is the maximum amount of data returned
	 * for any column value; it only applies to BINARY, VARBINARY,
	 * LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR columns. If the limit is
	 * exceeded, the excess data is silently discarded.
	 * 
	 * @return the current max column size limit; zero means unlimited
	 */
	public int getMaxFieldSize() throws SQLException {
		try {
			return rmiStatement_.getMaxFieldSize();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The maxFieldSize limit (in bytes) is set to limit the size of data that
	 * can be returned for any column value; it only applies to BINARY,
	 * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR fields. If the
	 * limit is exceeded, the excess data is silently discarded. For maximum
	 * portability use values greater than 256.
	 * 
	 * @param max
	 *            the new max column size limit; zero means unlimited
	 */
	public void setMaxFieldSize(int max) throws SQLException {
		try {
			rmiStatement_.setMaxFieldSize(max);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The maxRows limit is the maximum number of rows that a ResultSet can
	 * contain. If the limit is exceeded, the excess rows are silently dropped.
	 * 
	 * @return the current max row limit; zero means unlimited
	 */
	public int getMaxRows() throws SQLException {
		try {
			return rmiStatement_.getMaxRows();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The maxRows limit is set to limit the number of rows that any ResultSet
	 * can contain. If the limit is exceeded, the excess rows are silently
	 * dropped.
	 * 
	 * @param max
	 *            the new max rows limit; zero means unlimited
	 */
	public void setMaxRows(int max) throws SQLException {
		try {
			rmiStatement_.setMaxRows(max);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * If escape scanning is on (the default), the driver will do escape
	 * substitution before sending the SQL to the database.
	 * 
	 * @param enable
	 *            true to enable; false to disable
	 */
	public void setEscapeProcessing(boolean enable) throws SQLException {
		try {
			rmiStatement_.setEscapeProcessing(enable);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The queryTimeout limit is the number of seconds the driver will wait for
	 * a Statement to execute. If the limit is exceeded, a SQLException is
	 * thrown.
	 * 
	 * @return the current query timeout limit in seconds; zero means unlimited
	 */
	public int getQueryTimeout() throws SQLException {
		try {
			return rmiStatement_.getQueryTimeout();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The queryTimeout limit is the number of seconds the driver will wait for
	 * a Statement to execute. If the limit is exceeded, a SQLException is
	 * thrown.
	 * 
	 * @param seconds
	 *            the new query timeout limit in seconds; zero means unlimited
	 */
	public void setQueryTimeout(int seconds) throws SQLException {
		try {
			rmiStatement_.setQueryTimeout(seconds);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Cancel can be used by one thread to cancel a statement that is being
	 * executed by another thread.
	 */
	public void cancel() throws SQLException {
		try {
			rmiStatement_.cancel();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The first warning reported by calls on this Statement is returned. A
	 * Statment's execute methods clear its SQLWarning chain. Subsequent
	 * Statement warnings will be chained to this SQLWarning.
	 * 
	 * <p>
	 * The warning chain is automatically cleared each time a statement is
	 * (re)executed.
	 * 
	 * <P>
	 * <B>Note:</B> If you are processing a ResultSet then any warnings
	 * associated with ResultSet reads will be chained on the ResultSet object.
	 * 
	 * @return the first SQLWarning or null
	 */
	public SQLWarning getWarnings() throws SQLException {
		try {
			return rmiStatement_.getWarnings();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * After this call, getWarnings returns null until a new warning is reported
	 * for this Statement.
	 */
	public void clearWarnings() throws SQLException {
		try {
			rmiStatement_.clearWarnings();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * setCursorname defines the SQL cursor name that will be used by subsequent
	 * Statement execute methods. This name can then be used in SQL positioned
	 * update/delete statements to identify the current row in the ResultSet
	 * generated by this statement. If the database doesn't support positioned
	 * update/delete, this method is a noop.
	 * 
	 * <P>
	 * <B>Note:</B> By definition, positioned update/delete execution must be
	 * done by a different Statement than the one which generated the ResultSet
	 * being used for positioning. Also, cursor names must be unique within a
	 * Connection.
	 * 
	 * @param name
	 *            the new cursor name.
	 */
	public void setCursorName(String name) throws SQLException {
		try {
			rmiStatement_.setCursorName(name);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// ----------------------- Multiple Results --------------------------

	/**
	 * Execute a SQL statement that may return multiple results. Under some
	 * (uncommon) situations a single SQL statement may return multiple result
	 * sets and/or update counts. Normally you can ignore this, unless you're
	 * executing a stored procedure that you know may return multiple results,
	 * or unless you're dynamically executing an unknown SQL string. The
	 * "execute", "getMoreResults", "getResultSet" and "getUpdateCount" methods
	 * let you navigate through multiple results.
	 * 
	 * The "execute" method executes a SQL statement and indicates the form of
	 * the first result. You can then use getResultSet or getUpdateCount to
	 * retrieve the result, and getMoreResults to move to any subsequent
	 * result(s).
	 * 
	 * @param sql
	 *            any SQL statement
	 * @return true if the next result is a ResultSet; false if it is an update
	 *         count or there are no more results
	 * @see #getResultSet
	 * @see #getUpdateCount
	 * @see #getMoreResults
	 */
	public boolean execute(String sql) throws SQLException {
		try {
			return rmiStatement_.execute(sql);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * getResultSet returns the current result as a ResultSet. It should only be
	 * called once per result.
	 * 
	 * @return the current result as a ResultSet; null if the result is an
	 *         update count or there are no more results
	 * @see #execute
	 */
	public java.sql.ResultSet getResultSet() throws SQLException {
		ResultSet rs = null;
		try {
			RJResultSetInterface rjrsi = rmiStatement_.getResultSet();

			// only create a local ResultSet if one actually existed on the
			// server
			// Thanks to Phil Lopez from Informix for the fix...
			// See also RJStatementServer.java's getResultSet()
			if (rjrsi != null) {
				rs = new RJResultSet(rjrsi, this);
			}

		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}

		return rs;
	}

	/**
	 * getUpdateCount returns the current result as an update count; if the
	 * result is a ResultSet or there are no more results, -1 is returned. It
	 * should only be called once per result.
	 * 
	 * @return the current result as an update count; -1 if it is a ResultSet or
	 *         there are no more results
	 * @see #execute
	 */
	public int getUpdateCount() throws SQLException {
		try {
			return rmiStatement_.getUpdateCount();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * getMoreResults moves to a Statement's next result. It returns true if
	 * this result is a ResultSet. getMoreResults also implicitly closes any
	 * current ResultSet obtained with getResultSet.
	 * 
	 * There are no more results when (!getMoreResults() && (getUpdateCount() ==
	 * -1)
	 * 
	 * @return true if the next result is a ResultSet; false if it is an update
	 *         count or there are no more results
	 * @see #execute
	 */
	public boolean getMoreResults() throws SQLException {
		try {
			return rmiStatement_.getMoreResults();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// JDBC 2.0 methods
	public void setFetchSize(int rows) throws SQLException {
		try {
			rmiStatement_.setFetchSize(rows);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void setFetchDirection(int dir) throws SQLException {
		try {
			rmiStatement_.setFetchDirection(dir);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getResultSetType() throws SQLException {
		try {
			return rmiStatement_.getResultSetType();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getResultSetConcurrency() throws SQLException {
		try {
			return rmiStatement_.getResultSetConcurrency();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getFetchSize() throws SQLException {
		try {
			return rmiStatement_.getFetchSize();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getFetchDirection() throws SQLException {
		try {
			return rmiStatement_.getFetchDirection();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Connection getConnection() throws SQLException {
		return connection_;
	}

	public int[] executeBatch() throws SQLException {
		try {
			return rmiStatement_.executeBatch();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void clearBatch() throws SQLException {
		try {
			rmiStatement_.clearBatch();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void addBatch(String sql) throws SQLException {
		try {
			rmiStatement_.addBatch(sql);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// JDBC 3.0 methods
	public boolean getMoreResults(int current) throws SQLException {
		try {
			return rmiStatement_.getMoreResults(current);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public ResultSet getGeneratedKeys() throws SQLException {
		try {
			return new RJResultSet(rmiStatement_.getGeneratedKeys(), this);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		try {
			return rmiStatement_.executeUpdate(sql, autoGeneratedKeys);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int executeUpdate(String sql, int columnIndexes[])
			throws SQLException {
		try {
			return rmiStatement_.executeUpdate(sql, columnIndexes);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int executeUpdate(String sql, String columnNames[])
			throws SQLException {
		try {
			return rmiStatement_.executeUpdate(sql, columnNames);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		try {
			return rmiStatement_.execute(sql, autoGeneratedKeys);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean execute(String sql, int columnIndexes[]) throws SQLException {
		try {
			return rmiStatement_.execute(sql, columnIndexes);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean execute(String sql, String columnNames[])
			throws SQLException {
		try {
			return rmiStatement_.execute(sql, columnNames);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getResultSetHoldability() throws SQLException {
		try {
			return rmiStatement_.getResultSetHoldability();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean isClosed() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean isPoolable() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}
};
