/**
 * RmiJdbc client/server JDBC Driver
 * (C) GIE Dyade (Groupe BULL / INRIA Research Center) 1997
 *
 * @version     1.0
 * @author      Pierre-Yves Gibello (pierreyves.gibello@experlog.com)
 *              Additional SSL Support
 *              Douglas Hammond(djhammond@sympatico.ca)
 */

package org.objectweb.rmijdbc;

import java.sql.*;
import java.rmi.*;
import java.rmi.server.UnicastRemoteObject;
import java.rmi.server.Unreferenced;

/**
 * <P>
 * A Statement object is used for executing a static SQL statement and obtaining
 * the results produced by it.
 * 
 * <P>
 * Only one ResultSet per Statement can be open at any point in time. Therefore,
 * if the reading of one ResultSet is interleaved with the reading of another,
 * each must have been generated by different Statements. All statement execute
 * methods implicitly close a statment's current ResultSet if an open one
 * exists.
 * 
 * @see Connection#createStatement
 * @see ResultSet
 */
public class RJStatementServer extends UnicastRemoteObject implements RJStatementInterface, Unreferenced {

	private static final long serialVersionUID = 3855603263026175678L;

	java.sql.Statement jdbcStatement_;

	public RJStatementServer(java.sql.Statement s)
			throws java.rmi.RemoteException {
		super(RMIRepository.rmiJdbcListenerPort,
				RMIRepository.rmiClientSocketFactory,
				RMIRepository.rmiServerSocketFactory);
		jdbcStatement_ = s;
	}

	public void unreferenced() {
		Runtime.getRuntime().gc();
	}

	protected void finalize() throws Throwable {
		if (jdbcStatement_ != null)
			jdbcStatement_.close();
		Runtime.getRuntime().gc();
	}

	/**
	 * Execute a SQL statement that returns a single ResultSet.
	 * 
	 * @param sql
	 *            typically this is a static SQL SELECT statement
	 * @return a ResultSet that contains the data produced by the query; never
	 *         null
	 */
	public RJResultSetInterface executeQuery(String sql)
			throws java.rmi.RemoteException, SQLException {
		return new RJResultSetServer(jdbcStatement_.executeQuery(sql));
	}

	/**
	 * Execute a SQL INSERT, UPDATE or DELETE statement. In addition, SQL
	 * statements that return nothing such as SQL DDL statements can be
	 * executed.
	 * 
	 * @param sql
	 *            a SQL INSERT, UPDATE or DELETE statement or a SQL statement
	 *            that returns nothing
	 * @return either the row count for INSERT, UPDATE or DELETE or 0 for SQL
	 *         statements that return nothing
	 */
	public int executeUpdate(String sql) throws java.rmi.RemoteException,
			SQLException {
		return jdbcStatement_.executeUpdate(sql);
	}

	/**
	 * In many cases, it is desirable to immediately release a Statements's
	 * database and JDBC resources instead of waiting for this to happen when it
	 * is automatically closed; the close method provides this immediate
	 * release.
	 * 
	 * <P>
	 * <B>Note:</B> A Statement is automatically closed when it is garbage
	 * collected. When a Statement is closed, its current ResultSet, if one
	 * exists, is also closed.
	 */
	public void close() throws java.rmi.RemoteException, SQLException {
		if (jdbcStatement_ != null)
			jdbcStatement_.close();
	}

	// ----------------------------------------------------------------------

	/**
	 * The maxFieldSize limit (in bytes) is the maximum amount of data returned
	 * for any column value; it only applies to BINARY, VARBINARY,
	 * LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR columns. If the limit is
	 * exceeded, the excess data is silently discarded.
	 * 
	 * @return the current max column size limit; zero means unlimited
	 */
	public int getMaxFieldSize() throws java.rmi.RemoteException, SQLException {
		return jdbcStatement_.getMaxFieldSize();
	}

	/**
	 * The maxFieldSize limit (in bytes) is set to limit the size of data that
	 * can be returned for any column value; it only applies to BINARY,
	 * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR fields. If the
	 * limit is exceeded, the excess data is silently discarded. For maximum
	 * portability use values greater than 256.
	 * 
	 * @param max
	 *            the new max column size limit; zero means unlimited
	 */
	public void setMaxFieldSize(int max) throws java.rmi.RemoteException,
			SQLException {
		jdbcStatement_.setMaxFieldSize(max);
	}

	/**
	 * The maxRows limit is the maximum number of rows that a ResultSet can
	 * contain. If the limit is exceeded, the excess rows are silently dropped.
	 * 
	 * @return the current max row limit; zero means unlimited
	 */
	public int getMaxRows() throws java.rmi.RemoteException, SQLException {
		return jdbcStatement_.getMaxRows();
	}

	/**
	 * The maxRows limit is set to limit the number of rows that any ResultSet
	 * can contain. If the limit is exceeded, the excess rows are silently
	 * dropped.
	 * 
	 * @param max
	 *            the new max rows limit; zero means unlimited
	 */
	public void setMaxRows(int max) throws java.rmi.RemoteException,
			SQLException {
		jdbcStatement_.setMaxRows(max);
	}

	/**
	 * If escape scanning is on (the default), the driver will do escape
	 * substitution before sending the SQL to the database.
	 * 
	 * @param enable
	 *            true to enable; false to disable
	 */
	public void setEscapeProcessing(boolean enable)
			throws java.rmi.RemoteException, SQLException {
		jdbcStatement_.setEscapeProcessing(enable);
	}

	/**
	 * The queryTimeout limit is the number of seconds the driver will wait for
	 * a Statement to execute. If the limit is exceeded, a
	 * java.rmi.RemoteException is thrown.
	 * 
	 * @return the current query timeout limit in seconds; zero means unlimited
	 */
	public int getQueryTimeout() throws java.rmi.RemoteException, SQLException {
		return jdbcStatement_.getQueryTimeout();
	}

	/**
	 * The queryTimeout limit is the number of seconds the driver will wait for
	 * a Statement to execute. If the limit is exceeded, a
	 * java.rmi.RemoteException is thrown.
	 * 
	 * @param seconds
	 *            the new query timeout limit in seconds; 0 means unlimited
	 */
	public void setQueryTimeout(int seconds) throws java.rmi.RemoteException,
			SQLException {
		jdbcStatement_.setQueryTimeout(seconds);
	}

	/**
	 * Cancel can be used by one thread to cancel a statement that is being
	 * executed by another thread.
	 */
	public void cancel() throws java.rmi.RemoteException, SQLException {
		jdbcStatement_.cancel();
	}

	/**
	 * The first warning reported by calls on this Statement is returned. A
	 * Statment's execute methods clear its SQLWarning chain. Subsequent
	 * Statement warnings will be chained to this SQLWarning.
	 * 
	 * <p>
	 * The warning chain is automatically cleared each time a statement is
	 * (re)executed.
	 * 
	 * <P>
	 * <B>Note:</B> If you are processing a ResultSet then any warnings
	 * associated with ResultSet reads will be chained on the ResultSet object.
	 * 
	 * @return the first SQLWarning or null
	 */
	public SQLWarning getWarnings() throws java.rmi.RemoteException,
			SQLException {
		return jdbcStatement_.getWarnings();
	}

	/**
	 * After this call, getWarnings returns null until a new warning is reported
	 * for this Statement.
	 */
	public void clearWarnings() throws java.rmi.RemoteException, SQLException {
		jdbcStatement_.clearWarnings();
	}

	/**
	 * setCursorname defines the SQL cursor name that will be used by subsequent
	 * Statement execute methods. This name can then be used in SQL positioned
	 * update/delete statements to identify the current row in the ResultSet
	 * generated by this statement. If the database doesn't support positioned
	 * update/delete, this method is a noop.
	 * 
	 * <P>
	 * <B>Note:</B> By definition, positioned update/delete execution must be
	 * done by a different Statement than the one which generated the ResultSet
	 * being used for positioning. Also, cursor names must be unique within a
	 * Connection.
	 * 
	 * @param name
	 *            the new cursor name.
	 */
	public void setCursorName(String name) throws java.rmi.RemoteException,
			SQLException {
		jdbcStatement_.setCursorName(name);
	}

	// ----------------------- Multiple Results --------------------------

	/**
	 * Execute a SQL statement that may return multiple results. Under some
	 * (uncommon) situations a single SQL statement may return multiple result
	 * sets and/or update counts. Normally you can ignore this, unless you're
	 * executing a stored procedure that you know may return multiple results,
	 * or unless you're dynamically executing an unknown SQL string. The
	 * "execute", "getMoreResults", "getResultSet" and "getUpdateCount" methods
	 * let you navigate through multiple results.
	 * 
	 * The "execute" method executes a SQL statement and indicates the form of
	 * the first result. You can then use getResultSet or getUpdateCount to
	 * retrieve the result, and getMoreResults to move to any subsequent
	 * result(s).
	 * 
	 * @param sql
	 *            any SQL statement
	 * @return true if the next result is a ResultSet; false if it is an update
	 *         count or there are no more results
	 * @see #getResultSet
	 * @see #getUpdateCount
	 * @see #getMoreResults
	 */
	public boolean execute(String sql) throws java.rmi.RemoteException,
			SQLException {
		return jdbcStatement_.execute(sql);
	}

	/**
	 * getResultSet returns the current result as a ResultSet. It should only be
	 * called once per result.
	 * 
	 * @return the current result as a ResultSet; null if the result is an
	 *         update count or there are no more results
	 * @see #execute
	 */
	public RJResultSetInterface getResultSet() throws java.rmi.RemoteException,
			SQLException {

		RJResultSetServer rsServer = null;

		ResultSet rs = jdbcStatement_.getResultSet();

		// only return result set if it is not null
		// Thanks to Phil Lopez from Informix for the fix
		// See also RJStatement.java's getResultSet() method
		if (rs != null) {
			rsServer = new RJResultSetServer(rs);
		}

		return rsServer;
	}

	/**
	 * getUpdateCount returns the current result as an update count; if the
	 * result is a ResultSet or there are no more results, -1 is returned. It
	 * should only be called once per result.
	 * 
	 * @return the current result as an update count; -1 if it is a ResultSet or
	 *         there are no more results
	 * @see #execute
	 */
	public int getUpdateCount() throws java.rmi.RemoteException, SQLException {
		return jdbcStatement_.getUpdateCount();
	}

	/**
	 * getMoreResults moves to a Statement's next result. It returns true if
	 * this result is a ResultSet. getMoreResults also implicitly closes any
	 * current ResultSet obtained with getResultSet.
	 * 
	 * There are no more results when (!getMoreResults() && (getUpdateCount() ==
	 * -1)
	 * 
	 * @return true if the next result is a ResultSet; false if it is an update
	 *         count or there are no more results
	 * @see #execute
	 */
	public boolean getMoreResults() throws java.rmi.RemoteException,
			SQLException {
		return jdbcStatement_.getMoreResults();
	}

	// JDBC 2.0 methods
	public void setFetchSize(int rows) throws RemoteException, SQLException {
		jdbcStatement_.setFetchSize(rows);
	}

	public void setFetchDirection(int dir) throws RemoteException, SQLException {
		jdbcStatement_.setFetchDirection(dir);
	}

	public int getResultSetType() throws RemoteException, SQLException {
		return jdbcStatement_.getResultSetType();
	}

	public int getResultSetConcurrency() throws RemoteException, SQLException {
		return jdbcStatement_.getResultSetConcurrency();
	}

	public int getFetchSize() throws RemoteException, SQLException {
		return jdbcStatement_.getFetchSize();
	}

	public int getFetchDirection() throws RemoteException, SQLException {
		return jdbcStatement_.getFetchDirection();
	}

	public RJConnectionInterface getConnection() throws RemoteException,
			SQLException {
		return new RJConnectionServer(jdbcStatement_.getConnection());
	}

	public int[] executeBatch() throws RemoteException, SQLException {
		return jdbcStatement_.executeBatch();
	}

	public void clearBatch() throws RemoteException, SQLException {
		jdbcStatement_.clearBatch();
	}

	public void addBatch(String sql) throws RemoteException, SQLException {
		jdbcStatement_.addBatch(sql);
	}

	// JDBC 3.0 methods
	public boolean getMoreResults(int current) throws RemoteException,
			SQLException {
		return jdbcStatement_.getMoreResults(current);
	}

	public RJResultSetInterface getGeneratedKeys() throws RemoteException,
			SQLException {
		return new RJResultSetServer(jdbcStatement_.getGeneratedKeys());
	}

	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws RemoteException, SQLException {
		return jdbcStatement_.executeUpdate(sql, autoGeneratedKeys);
	}

	public int executeUpdate(String sql, int columnIndexes[])
			throws RemoteException, SQLException {
		return jdbcStatement_.executeUpdate(sql, columnIndexes);
	}

	public int executeUpdate(String sql, String columnNames[])
			throws RemoteException, SQLException {
		return jdbcStatement_.executeUpdate(sql, columnNames);
	}

	public boolean execute(String sql, int autoGeneratedKeys)
			throws RemoteException, SQLException {
		return jdbcStatement_.execute(sql, autoGeneratedKeys);
	}

	public boolean execute(String sql, int columnIndexes[])
			throws RemoteException, SQLException {
		return jdbcStatement_.execute(sql, columnIndexes);
	}

	public boolean execute(String sql, String columnNames[])
			throws RemoteException, SQLException {
		return jdbcStatement_.execute(sql, columnNames);
	}

	public int getResultSetHoldability() throws RemoteException, SQLException {
		return jdbcStatement_.getResultSetHoldability();
	}

};
