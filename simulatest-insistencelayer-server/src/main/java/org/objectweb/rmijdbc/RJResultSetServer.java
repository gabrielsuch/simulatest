/**
 * RmiJdbc client/server JDBC Driver
 * (C) GIE Dyade (Groupe BULL / INRIA Research Center) 1997
 *
 * @version     1.0
 * @author      Pierre-Yves Gibello (pierreyves.gibello@experlog.com)
 *              Additional SSL Support
 *              Douglas Hammond(djhammond@sympatico.ca)
 */

package org.objectweb.rmijdbc;

import java.io.*;
import java.math.BigDecimal;

import java.sql.*;
import java.rmi.*;
import java.rmi.server.UnicastRemoteObject;
import java.rmi.server.Unreferenced;

// TBD: WARNING This file contains a hack for InputStream class...
// InputStream is not serializable, of course !
// The right way would be to encapsulate InputStream in a RMI remote object
// (hope I'll find time to do that)

/**
 * <P>
 * A ResultSet provides access to a table of data generated by executing a
 * Statement. The table rows are retrieved in sequence. Within a row its column
 * values can be accessed in any order.
 * 
 * <P>
 * A ResultSet maintains a cursor pointing to its current row of data. Initially
 * the cursor is positioned before the first row. The 'next' method moves the
 * cursor to the next row.
 * 
 * <P>
 * The getXXX methods retrieve column values for the current row. You can
 * retrieve values either using the index number of the column, or by using the
 * name of the column. In general using the column index will be more efficient.
 * Columns are numbered from 1.
 * 
 * <P>
 * For maximum portability, ResultSet columns within each row should be read in
 * left-to-right order and each column should be read only once.
 * 
 * <P>
 * For the getXXX methods, the JDBC driver attempts to convert the underlying
 * data to the specified Java type and returns a suitable Java value. See the
 * JDBC specification for allowable mappings from SQL types to Java types with
 * the ResultSet.getXXX methods.
 * 
 * <P>
 * Column names used as input to getXXX methods are case insensitive. When
 * performing a getXXX using a column name, if several columns have the same
 * name, then the value of the first matching column will be returned.
 * 
 * <P>
 * A ResultSet is automatically closed by the Statement that generated it when
 * that Statement is closed, re-executed, or is used to retrieve the next result
 * from a sequence of multiple results.
 * 
 * <P>
 * The number, types and properties of a ResultSet's columns are provided by the
 * ResulSetMetaData object returned by the getMetaData method.
 * 
 * @see Statement#executeQuery
 * @see Statement#getResultSet
 * @see ResultSetMetaData
 */

public class RJResultSetServer extends UnicastRemoteObject implements
		RJResultSetInterface, Unreferenced {

	private static final long serialVersionUID = -3257842540789632685L;
	
	java.sql.ResultSet jdbcResultSet_;

	public RJResultSetServer(java.sql.ResultSet s)
			throws java.rmi.RemoteException {
		super(RMIRepository.rmiJdbcListenerPort,
				RMIRepository.rmiClientSocketFactory,
				RMIRepository.rmiServerSocketFactory);
		jdbcResultSet_ = s;
	}

	public void unreferenced() {
		Runtime.getRuntime().gc();
	}

	protected void finalize() throws Throwable {
		if (jdbcResultSet_ != null)
			jdbcResultSet_.close();
	}

	/**
	 * A ResultSet is initially positioned before its first row; the first call
	 * to next makes the first row the current row; the second call makes the
	 * second row the current row, etc.
	 * 
	 * <P>
	 * If an input stream from the previous row is open, it is implicitly
	 * closed. The ResultSet's warning chain is cleared when a new row is read.
	 * 
	 * @return true if the new current row is valid; false if there are no more
	 *         rows
	 */
	public boolean next() throws RemoteException, SQLException {
		return jdbcResultSet_.next();
	}

	/**
	 * In some cases, it is desirable to immediately release a ResultSet's
	 * database and JDBC resources instead of waiting for this to happen when it
	 * is automatically closed; the close method provides this immediate
	 * release.
	 * 
	 * <P>
	 * <B>Note:</B> A ResultSet is automatically closed by the Statement that
	 * generated it when that Statement is closed, re-executed, or is used to
	 * retrieve the next result from a sequence of multiple results. A ResultSet
	 * is also automatically closed when it is garbage collected.
	 */
	public void close() throws RemoteException, SQLException {
		if (jdbcResultSet_ != null)
			jdbcResultSet_.close();
	}

	/**
	 * A column may have the value of SQL NULL; wasNull reports whether the last
	 * column read had this special value. Note that you must first call getXXX
	 * on a column to try to read its value and then call wasNull() to find if
	 * the value was the SQL NULL.
	 * 
	 * @return true if last column read was SQL NULL
	 */
	public boolean wasNull() throws RemoteException, SQLException {
		return jdbcResultSet_.wasNull();
	}

	// ======================================================================
	// Methods for accessing results by column index
	// ======================================================================

	/**
	 * Get the value of a column in the current row as a Java String.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public String getString(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getString(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java boolean.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is false
	 */
	public boolean getBoolean(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getBoolean(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java byte.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public byte getByte(int columnIndex) throws RemoteException, SQLException {
		return jdbcResultSet_.getByte(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java short.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public short getShort(int columnIndex) throws RemoteException, SQLException {
		return jdbcResultSet_.getShort(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java int.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public int getInt(int columnIndex) throws RemoteException, SQLException {
		return jdbcResultSet_.getInt(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java long.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public long getLong(int columnIndex) throws RemoteException, SQLException {
		return jdbcResultSet_.getLong(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java float.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public float getFloat(int columnIndex) throws RemoteException, SQLException {
		return jdbcResultSet_.getFloat(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a Java double.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public double getDouble(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getDouble(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a java.lang.BigDecimal
	 * object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param scale
	 *            the number of digits to the right of the decimal
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	@SuppressWarnings("deprecation")
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getBigDecimal(columnIndex, scale);
	}

	/**
	 * Get the value of a column in the current row as a Java byte array. The
	 * bytes represent the raw values returned by the driver.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public byte[] getBytes(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getBytes(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Date object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Date getDate(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getDate(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Time object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Time getTime(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getTime(columnIndex);
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Timestamp
	 * object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Timestamp getTimestamp(int columnIndex)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getTimestamp(columnIndex);
	}

	/**
	 * A column value can be retrieved as a stream of ASCII characters and then
	 * read in chunks from the stream. This method is particularly suitable for
	 * retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into ASCII.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream. . Also, a stream may return 0 for
	 * available() whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of one byte ASCII characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// public java.io.InputStream getAsciiStream(int columnIndex)
	// TBD: This is a hack: InputStream is not serializable !
	public byte[] getAsciiStream(int columnIndex) throws RemoteException,
			SQLException {
		try {
			// I read the whole InputStream into a StringBuffer, then send the
			// StringBuffer's bytes to the client !! Awful, isn't it :(
			// The right way is to "RMIze" InputStream, or what ??
			InputStream s = jdbcResultSet_.getAsciiStream(columnIndex);
			return RJSerializer.toByteArray(s);
		} catch (IOException e) {
			throw new java.rmi.RemoteException(
					"RJResultSetServer::getAsciiStream()", e);
		}
	}

	/**
	 * A column value can be retrieved as a stream of Unicode characters and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into Unicode.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream. . Also, a stream may return 0 for
	 * available() whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of two byte Unicode characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// public java.io.InputStream getUnicodeStream(int columnIndex)
	// TBD: This is a hack: InputStream is not serializable !
	@SuppressWarnings("deprecation")
	public byte[] getUnicodeStream(int columnIndex) throws RemoteException,
			SQLException {
		try {
			// I read the whole InputStream into a StringBuffer, then send the
			// StringBuffer's bytes to the client !! Awful, isn't it :(
			// The right way is to "RMIze" InputStream, or what ??
			InputStream s = jdbcResultSet_.getUnicodeStream(columnIndex);
			return RJSerializer.toByteArray(s);
		} catch (IOException e) {
			throw new java.rmi.RemoteException(
					"RJResultSetServer::getUnicodeStream()", e);
		}
	}

	/**
	 ** TBD Proposed by P.Hearty - see below Reads all the bytes from an input
	 * stream into a bytes array. static byte[] getBytesFromInputStream
	 * (InputStream is) throws IOException { int numAvail = is.available();
	 * byte[] bytes = new byte[numAvail]; int readSoFar = 0; while (numAvail >
	 * 0) { int actualRead = is.read (bytes, readSoFar, numAvail); readSoFar +=
	 * actualRead; numAvail = is.available(); if (readSoFar+numAvail >
	 * bytes.length) { // need to expand the bytes buffer byte[] newBytes = new
	 * byte[(readSoFar+numAvail)*2]; System.arraycopy (bytes, 0, newBytes, 0,
	 * readSoFar); bytes = newBytes; } // if } // while return bytes; } //
	 * getBytesFromInputStream
	 */

	/**
	 * A column value can be retrieved as a stream of uninterpreted bytes and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARBINARY values.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream. Also, a stream may return 0 for available()
	 * whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of uninterpreted bytes. If the value is SQL NULL then the
	 *         result is null.
	 */
	// public java.io.InputStream getBinaryStream(int columnIndex)
	// TBD: This is a hack: InputStream is not serializable !
	public byte[] getBinaryStream(int columnIndex) throws RemoteException,
			SQLException {
		try {
			InputStream s = jdbcResultSet_.getBinaryStream(columnIndex);
			return RJSerializer.toByteArray(s);
			/**
			 * TBD Proposed by P. Hearty return getBytesFromInputStream (s);
			 **/
		} catch (IOException e) {
			throw new java.rmi.RemoteException(
					"RJResultSetServer::getBinaryStream()", e);
		}
	}

	// ======================================================================
	// Methods for accessing results by column name
	// ======================================================================

	/**
	 * Get the value of a column in the current row as a Java String.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public String getString(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getString(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java boolean.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is false
	 */
	public boolean getBoolean(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getBoolean(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java byte.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public byte getByte(String columnName) throws RemoteException, SQLException {
		return jdbcResultSet_.getByte(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java short.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public short getShort(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getShort(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java int.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public int getInt(String columnName) throws RemoteException, SQLException {
		return jdbcResultSet_.getInt(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java long.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public long getLong(String columnName) throws RemoteException, SQLException {
		return jdbcResultSet_.getLong(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java float.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public float getFloat(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getFloat(columnName);
	}

	/**
	 * Get the value of a column in the current row as a Java double.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public double getDouble(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getDouble(columnName);
	}

	/**
	 * Get the value of a column in the current row as a java.lang.BigDecimal
	 * object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @param scale
	 *            the number of digits to the right of the decimal
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	@SuppressWarnings("deprecation")
	public BigDecimal getBigDecimal(String columnName, int scale)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getBigDecimal(columnName, scale);
	}

	/**
	 * Get the value of a column in the current row as a Java byte array. The
	 * bytes represent the raw values returned by the driver.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public byte[] getBytes(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getBytes(columnName);
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Date object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Date getDate(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getDate(columnName);
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Time object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Time getTime(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getTime(columnName);
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Timestamp
	 * object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Timestamp getTimestamp(String columnName)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getTimestamp(columnName);
	}

	/**
	 * A column value can be retrieved as a stream of ASCII characters and then
	 * read in chunks from the stream. This method is particularly suitable for
	 * retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into ASCII.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of one byte ASCII characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// public java.io.InputStream getAsciiStream(String columnName)
	// TBD: This is a hack: InputStream is not serializable !
	public byte[] getAsciiStream(String columnName) throws RemoteException,
			SQLException {
		try {
			// I read the whole InputStream into a StringBuffer, then send the
			// StringBuffer's bytes to the client !! Awful, isn't it :(
			// The right way is to "RMIze" InputStream, or what ??
			InputStream s = jdbcResultSet_.getAsciiStream(columnName);
			return RJSerializer.toByteArray(s);
			/**
			 * Proposed by P.Hearty return getBytesFromInputStream (s);
			 **/
		} catch (IOException e) {
			throw new java.rmi.RemoteException(
					"RJResultSetServer::getAsciiStream()", e);
		}
	}

	/**
	 * A column value can be retrieved as a stream of Unicode characters and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into Unicode.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of two byte Unicode characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// public java.io.InputStream getUnicodeStream(String columnName)
	// TBD: This is a hack: InputStream is not serializable !
	@SuppressWarnings("deprecation")
	public byte[] getUnicodeStream(String columnName) throws RemoteException,
			SQLException {
		try {
			// I read the whole InputStream into a StringBuffer, then send the
			// StringBuffer's bytes to the client !! Awful, isn't it :(
			// The right way is to "RMIze" InputStream, or what ??
			InputStream s = jdbcResultSet_.getUnicodeStream(columnName);
			return RJSerializer.toByteArray(s);
			/**
			 * Proposed by P.Hearty return getBytesFromInputStream (s);
			 **/
		} catch (IOException e) {
			throw new java.rmi.RemoteException(
					"RJResultSetServer::getUnicodeStream()", e);
		}
	}

	/**
	 * A column value can be retrieved as a stream of uninterpreted bytes and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARBINARY values.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of uninterpreted bytes. If the value is SQL NULL then the
	 *         result is null.
	 */
	// public java.io.InputStream getBinaryStream(String columnName)
	// TBD: This is a hack: InputStream is not serializable !
	public byte[] getBinaryStream(String columnName) throws RemoteException,
			SQLException {
		try {
			// I read the whole InputStream into a StringBuffer, then send the
			// StringBuffer's bytes to the client !! Awful, isn't it :(
			// The right way is to "RMIze" InputStream, or what ??
			InputStream s = jdbcResultSet_.getBinaryStream(columnName);
			return RJSerializer.toByteArray(s);
			/**
			 * Proposed by P.Hearty return getBytesFromInputStream (s);
			 **/
		} catch (IOException e) {
			throw new java.rmi.RemoteException(
					"RJResultSetServer::getBinaryStream()", e);
		}
	}

	// =====================================================================
	// Advanced features:
	// =====================================================================

	/**
	 * <p>
	 * The first warning reported by calls on this ResultSet is returned.
	 * Subsequent ResultSet warnings will be chained to this SQLWarning.
	 * 
	 * <P>
	 * The warning chain is automatically cleared each time a new row is read.
	 * 
	 * <P>
	 * <B>Note:</B> This warning chain only covers warnings caused by ResultSet
	 * methods. Any warning caused by statement methods (such as reading OUT
	 * parameters) will be chained on the Statement object.
	 * 
	 * @return the first SQLWarning or null
	 */
	public SQLWarning getWarnings() throws RemoteException, SQLException {
		return jdbcResultSet_.getWarnings();
	}

	/**
	 * After this call getWarnings returns null until a new warning is reported
	 * for this ResultSet.
	 */
	public void clearWarnings() throws RemoteException, SQLException {
		jdbcResultSet_.clearWarnings();
	}

	/**
	 * Get the name of the SQL cursor used by this ResultSet.
	 * 
	 * <P>
	 * In SQL, a result table is retrieved through a cursor that is named. The
	 * current row of a result can be updated or deleted using a positioned
	 * update/delete statement that references the cursor name.
	 * 
	 * <P>
	 * JDBC supports this SQL feature by providing the name of the SQL cursor
	 * used by a ResultSet. The current row of a ResultSet is also the current
	 * row of this SQL cursor.
	 * 
	 * <P>
	 * <B>Note:</B> If positioned update is not supported a
	 * java.rmi.RemoteException is thrown
	 * 
	 * @return the ResultSet's SQL cursor name
	 */
	public String getCursorName() throws RemoteException, SQLException {
		return jdbcResultSet_.getCursorName();
	}

	/**
	 * The number, types and properties of a ResultSet's columns are provided by
	 * the getMetaData method.
	 * 
	 * @return the description of a ResultSet's columns
	 */
	public RJResultSetMetaDataInterface getMetaData() throws RemoteException,
			SQLException {
		return new RJResultSetMetaDataServer(jdbcResultSet_.getMetaData());
	}

	/**
	 * <p>
	 * Get the value of a column in the current row as a Java object.
	 * 
	 * <p>
	 * This method will return the value of the given column as a Java object.
	 * The type of the Java object will be the default Java Object type
	 * corresponding to the column's SQL type, following the mapping specified
	 * in the JDBC spec.
	 * 
	 * <p>
	 * This method may also be used to read datatabase specific abstract data
	 * types.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return A java.lang.Object holding the column value.
	 */
	public Object getObject(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getObject(columnIndex);
	}

	/**
	 * <p>
	 * Get the value of a column in the current row as a Java object.
	 * 
	 * <p>
	 * This method will return the value of the given column as a Java object.
	 * The type of the Java object will be the default Java Object type
	 * corresponding to the column's SQL type, following the mapping specified
	 * in the JDBC spec.
	 * 
	 * <p>
	 * This method may also be used to read datatabase specific abstract data
	 * types.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return A java.lang.Object holding the column value.
	 */
	public Object getObject(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getObject(columnName);
	}

	// ----------------------------------------------------------------

	/**
	 * Map a Resultset column name to a ResultSet column index.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @return the column index
	 */

	public int findColumn(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.findColumn(columnName);
	}

	// JDBC 2.0 methods
	// Implementation added Aug 2000 by Peter Hearty (peter.hearty@lutris.com).

	public void updateTimestamp(String columnName, Timestamp x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateTimestamp(columnName, x);
	}

	public void updateTimestamp(int columnIndex, Timestamp x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateTimestamp(columnIndex, x);
	}

	public void updateTime(String columnName, Time x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateTime(columnName, x);
	}

	public void updateTime(int columnIndex, Time x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateTime(columnIndex, x);
	}

	public void updateString(String columnName, String x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateString(columnName, x);
	}

	public void updateString(int columnIndex, String x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateString(columnIndex, x);
	}

	public void updateShort(int columnIndex, short x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateShort(columnIndex, x);
	}

	public void updateShort(String columnName, short x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateShort(columnName, x);
	}

	public void updateRow() throws RemoteException, SQLException {
		jdbcResultSet_.updateRow();
	}

	public void updateObject(String columnName, Object x, int scale)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateObject(columnName, x, scale);
	}

	public void updateObject(String columnName, Object x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateObject(columnName, x);
	}

	public void updateObject(int columnIndex, Object x, int scale)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateObject(columnIndex, x, scale);
	}

	public void updateObject(int columnIndex, Object x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateObject(columnIndex, x);
	}

	public void updateNull(String columnName) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateNull(columnName);
	}

	public void updateNull(int columnIndex) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateNull(columnIndex);
	}

	public void updateLong(String columnName, long x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateLong(columnName, x);
	}

	public void updateLong(int columnIndex, long x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateLong(columnIndex, x);
	}

	public void updateInt(String columnName, int x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateInt(columnName, x);
	}

	public void updateInt(int columnIndex, int x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateInt(columnIndex, x);
	}

	public void updateFloat(String columnName, float x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateFloat(columnName, x);
	}

	public void updateFloat(int columnIndex, float x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateFloat(columnIndex, x);
	}

	public void updateDouble(String columnName, double x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateDouble(columnName, x);
	}

	public void updateDouble(int columnIndex, double x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateDouble(columnIndex, x);
	}

	public void updateDate(String columnName, Date x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateDate(columnName, x);
	}

	public void updateDate(int columnIndex, Date x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateDate(columnIndex, x);
	}

	public void updateCharacterStream(String columnName, java.io.Reader reader,
			int length) throws RemoteException, SQLException {
		jdbcResultSet_.updateCharacterStream(columnName, reader, length);
	}

	public void updateCharacterStream(int columnIndex, java.io.Reader x,
			int length) throws RemoteException, SQLException {
		jdbcResultSet_.updateCharacterStream(columnIndex, x, length);
	}

	public void updateBytes(String columnName, byte[] x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBytes(columnName, x);
	}

	public void updateBytes(int columnIndex, byte[] x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateBytes(columnIndex, x);
	}

	public void updateByte(String columnName, byte x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateByte(columnName, x);
	}

	public void updateByte(int columnIndex, byte x) throws RemoteException,
			SQLException {
		jdbcResultSet_.updateByte(columnIndex, x);
	}

	public void updateBoolean(String columnName, boolean x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBoolean(columnName, x);
	}

	public void updateBoolean(int columnIndex, boolean x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBoolean(columnIndex, x);
	}

	public void updateBinaryStream(String columnName, java.io.InputStream x,
			int length) throws RemoteException, SQLException {
		jdbcResultSet_.updateBinaryStream(columnName, x, length);
	}

	public void updateBinaryStream(int columnIndex, java.io.InputStream x,
			int length) throws RemoteException, SQLException {
		jdbcResultSet_.updateBinaryStream(columnIndex, x, length);
	}

	public void updateBigDecimal(String columnName, BigDecimal x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBigDecimal(columnName, x);
	}

	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBigDecimal(columnIndex, x);
	}

	public void updateAsciiStream(String columnName, java.io.InputStream x,
			int length) throws RemoteException, SQLException {
		jdbcResultSet_.updateAsciiStream(columnName, x, length);
	}

	public void updateAsciiStream(int columnIndex, java.io.InputStream x,
			int length) throws RemoteException, SQLException {
		jdbcResultSet_.updateAsciiStream(columnIndex, x, length);
	}

	public void setFetchSize(int rows) throws RemoteException, SQLException {
		jdbcResultSet_.setFetchSize(rows);
	}

	public void setFetchDirection(int direction) throws RemoteException,
			SQLException {
		jdbcResultSet_.setFetchDirection(direction);
	}

	public boolean rowUpdated() throws RemoteException, SQLException {
		return jdbcResultSet_.rowUpdated();
	}

	public boolean rowInserted() throws RemoteException, SQLException {
		return jdbcResultSet_.rowInserted();
	}

	public boolean rowDeleted() throws RemoteException, SQLException {
		return jdbcResultSet_.rowDeleted();
	}

	public boolean relative(int rows) throws RemoteException, SQLException {
		return jdbcResultSet_.relative(rows);
	}

	public void refreshRow() throws RemoteException, SQLException {
		jdbcResultSet_.refreshRow();
	}

	public boolean previous() throws RemoteException, SQLException {
		return jdbcResultSet_.previous();
	}

	public void moveToInsertRow() throws RemoteException, SQLException {
		jdbcResultSet_.moveToInsertRow();
	}

	public void moveToCurrentRow() throws RemoteException, SQLException {
		jdbcResultSet_.moveToCurrentRow();
	}

	public boolean last() throws RemoteException, SQLException {
		return jdbcResultSet_.last();
	}

	public boolean isLast() throws RemoteException, SQLException {
		return jdbcResultSet_.isLast();
	}

	public boolean isFirst() throws RemoteException, SQLException {
		return jdbcResultSet_.isFirst();
	}

	public boolean isBeforeFirst() throws RemoteException, SQLException {
		return jdbcResultSet_.isBeforeFirst();
	}

	public boolean isAfterLast() throws RemoteException, SQLException {
		return jdbcResultSet_.isAfterLast();
	}

	public void insertRow() throws RemoteException, SQLException {
		jdbcResultSet_.insertRow();
	}

	public int getType() throws RemoteException, SQLException {
		return jdbcResultSet_.getType();
	}

	public Timestamp getTimestamp(String columnName, java.util.Calendar cal)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getTimestamp(columnName, cal);
	}

	public Timestamp getTimestamp(int columnIndex, java.util.Calendar cal)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getTimestamp(columnIndex, cal);
	}

	public Time getTime(String columnName, java.util.Calendar cal)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getTime(columnName, cal);
	}

	public Time getTime(int columnIndex, java.util.Calendar cal)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getTime(columnIndex, cal);
	}

	public RJStatementInterface getStatement() throws RemoteException,
			SQLException {
		return new RJStatementServer(jdbcResultSet_.getStatement());
	}

	public RJRefInterface getRef(String colName) throws RemoteException,
			SQLException {
		return new RJRefServer(jdbcResultSet_.getRef(colName));
	}

	public RJRefInterface getRef(int i) throws RemoteException, SQLException {
		return new RJRefServer(jdbcResultSet_.getRef(i));
	}

	public Object getObject(String colName, java.util.Map<String,Class<?>> map)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getObject(colName, map);
	}

	public Object getObject(int i, java.util.Map<String,Class<?>> map) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getObject(i, map);
	}

	public int getFetchSize() throws RemoteException, SQLException {
		return jdbcResultSet_.getFetchSize();
	}

	public int getFetchDirection() throws RemoteException, SQLException {
		return jdbcResultSet_.getFetchDirection();
	}

	public Date getDate(String columnName, java.util.Calendar cal)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getDate(columnName, cal);
	}

	public Date getDate(int columnIndex, java.util.Calendar cal)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getDate(columnIndex, cal);
	}

	public int getConcurrency() throws RemoteException, SQLException {
		return jdbcResultSet_.getConcurrency();
	}

	public RJClobInterface getClob(String colName) throws RemoteException,
			SQLException {
		return new RJClobServer(jdbcResultSet_.getClob(colName));
	}

	public RJClobInterface getClob(int i) throws RemoteException, SQLException {
		return new RJClobServer(jdbcResultSet_.getClob(i));
	}

	// TBD serialization pb ??
	public java.io.Reader getCharacterStream(String columnName)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getCharacterStream(columnName);
	}

	// TBD serialization pb ??
	public java.io.Reader getCharacterStream(int columnIndex)
			throws RemoteException, SQLException {
		return jdbcResultSet_.getCharacterStream(columnIndex);
	}

	public RJBlobInterface getBlob(String colName) throws RemoteException,
			SQLException {
		return new RJBlobServer(jdbcResultSet_.getBlob(colName));
	}

	public RJBlobInterface getBlob(int i) throws RemoteException, SQLException {
		return new RJBlobServer(jdbcResultSet_.getBlob(i));
	}

	public BigDecimal getBigDecimal(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getBigDecimal(columnName);
	}

	public BigDecimal getBigDecimal(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getBigDecimal(columnIndex);
	}

	public RJArrayInterface getArray(String colName) throws RemoteException,
			SQLException {
		return new RJArrayServer(jdbcResultSet_.getArray(colName));
	}

	public RJArrayInterface getArray(int i) throws RemoteException,
			SQLException {
		return new RJArrayServer(jdbcResultSet_.getArray(i));
	}

	public boolean first() throws RemoteException, SQLException {
		return jdbcResultSet_.first();
	}

	public void cancelRowUpdates() throws RemoteException, SQLException {
		jdbcResultSet_.cancelRowUpdates();
	}

	public void deleteRow() throws RemoteException, SQLException {
		jdbcResultSet_.deleteRow();
	}

	public void beforeFirst() throws RemoteException, SQLException {
		jdbcResultSet_.beforeFirst();
	}

	public void afterLast() throws RemoteException, SQLException {
		jdbcResultSet_.afterLast();
	}

	public boolean absolute(int row) throws RemoteException, SQLException {
		return jdbcResultSet_.absolute(row);
	}

	public int getRow() throws RemoteException, SQLException {
		return jdbcResultSet_.getRow();
	}

	// -------------------------- JDBC 3.0
	// ----------------------------------------

	public java.net.URL getURL(int columnIndex) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getURL(columnIndex);
	}

	public java.net.URL getURL(String columnName) throws RemoteException,
			SQLException {
		return jdbcResultSet_.getURL(columnName);
	}

	public void updateRef(int columnIndex, java.sql.Ref x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateRef(columnIndex, x);
	}

	public void updateRef(String columnName, java.sql.Ref x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateRef(columnName, x);
	}

	public void updateBlob(int columnIndex, java.sql.Blob x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBlob(columnIndex, x);
	}

	public void updateBlob(String columnName, java.sql.Blob x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateBlob(columnName, x);
	}

	public void updateClob(int columnIndex, java.sql.Clob x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateClob(columnIndex, x);
	}

	public void updateClob(String columnName, java.sql.Clob x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateClob(columnName, x);
	}

	public void updateArray(int columnIndex, java.sql.Array x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateArray(columnIndex, x);
	}

	public void updateArray(String columnName, java.sql.Array x)
			throws RemoteException, SQLException {
		jdbcResultSet_.updateArray(columnName, x);
	}

};
