/**
 * RmiJdbc client/server JDBC Driver
 * (C) GIE Dyade (Groupe BULL / INRIA Research Center) 1997
 *
 * @version     1.0
 * @author      Pierre-Yves Gibello (pierreyves.gibello@experlog.com)
 */

package org.objectweb.rmijdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.sql.*;
import java.util.Map;
import java.rmi.RemoteException;

// TBD: WARNING This file contains a hack for InputStream class...
// InputStream is not serializable, of course !
// The right way would be to encapsulate InputStream in a RMI remote object
// (hope I'll find time to do that)

/**
 * <P>
 * A ResultSet provides access to a table of data generated by executing a
 * Statement. The table rows are retrieved in sequence. Within a row its column
 * values can be accessed in any order.
 * 
 * <P>
 * A ResultSet maintains a cursor pointing to its current row of data. Initially
 * the cursor is positioned before the first row. The 'next' method moves the
 * cursor to the next row.
 * 
 * <P>
 * The getXXX methods retrieve column values for the current row. You can
 * retrieve values either using the index number of the column, or by using the
 * name of the column. In general using the column index will be more efficient.
 * Columns are numbered from 1.
 * 
 * <P>
 * For maximum portability, ResultSet columns within each row should be read in
 * left-to-right order and each column should be read only once.
 * 
 * <P>
 * For the getXXX methods, the JDBC driver attempts to convert the underlying
 * data to the specified Java type and returns a suitable Java value. See the
 * JDBC specification for allowable mappings from SQL types to Java types with
 * the ResultSet.getXXX methods.
 * 
 * <P>
 * Column names used as input to getXXX methods are case insensitive. When
 * performing a getXXX using a column name, if several columns have the same
 * name, then the value of the first matching column will be returned.
 * 
 * <P>
 * A ResultSet is automatically closed by the Statement that generated it when
 * that Statement is closed, re-executed, or is used to retrieve the next result
 * from a sequence of multiple results.
 * 
 * <P>
 * The number, types and properties of a ResultSet's columns are provided by the
 * ResulSetMetaData object returned by the getMetaData method.
 * 
 * @see Statement#executeQuery
 * @see Statement#getResultSet
 * @see ResultSetMetaData
 */

public class RJResultSet implements java.sql.ResultSet, java.io.Serializable {

	private static final long serialVersionUID = -6596436607506411527L;
	
	RJResultSetInterface rmiResultSet_;
	Statement statement_ = null;

	public RJResultSet(RJResultSetInterface r, Statement st) {
		rmiResultSet_ = r;
		statement_ = st;
	}

	/**
	 * A ResultSet is initially positioned before its first row; the first call
	 * to next makes the first row the current row; the second call makes the
	 * second row the current row, etc.
	 * 
	 * <P>
	 * If an input stream from the previous row is open, it is implicitly
	 * closed. The ResultSet's warning chain is cleared when a new row is read.
	 * 
	 * @return true if the new current row is valid; false if there are no more
	 *         rows
	 */
	public boolean next() throws java.sql.SQLException {
		try {
			return rmiResultSet_.next();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * In some cases, it is desirable to immediately release a ResultSet's
	 * database and JDBC resources instead of waiting for this to happen when it
	 * is automatically closed; the close method provides this immediate
	 * release.
	 * 
	 * <P>
	 * <B>Note:</B> A ResultSet is automatically closed by the Statement that
	 * generated it when that Statement is closed, re-executed, or is used to
	 * retrieve the next result from a sequence of multiple results. A ResultSet
	 * is also automatically closed when it is garbage collected.
	 */
	public void close() throws java.sql.SQLException {
		try {
			rmiResultSet_.close();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column may have the value of SQL NULL; wasNull reports whether the last
	 * column read had this special value. Note that you must first call getXXX
	 * on a column to try to read its value and then call wasNull() to find if
	 * the value was the SQL NULL.
	 * 
	 * @return true if last column read was SQL NULL
	 */
	public boolean wasNull() throws java.sql.SQLException {
		try {
			return rmiResultSet_.wasNull();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// ======================================================================
	// Methods for accessing results by column index
	// ======================================================================

	/**
	 * Get the value of a column in the current row as a Java String.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public String getString(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getString(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java boolean.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is false
	 */
	public boolean getBoolean(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getBoolean(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java byte.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public byte getByte(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getByte(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java short.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public short getShort(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getShort(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java int.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public int getInt(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getInt(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java long.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public long getLong(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getLong(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java float.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public float getFloat(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getFloat(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java double.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public double getDouble(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getDouble(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.lang.BigDecimal
	 * object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param scale
	 *            the number of digits to the right of the decimal
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws java.sql.SQLException {
		try {
			return rmiResultSet_.getBigDecimal(columnIndex, scale);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java byte array. The
	 * bytes represent the raw values returned by the driver.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public byte[] getBytes(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getBytes(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Date object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Date getDate(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getDate(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Time object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Time getTime(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getTime(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Timestamp
	 * object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Timestamp getTimestamp(int columnIndex)
			throws java.sql.SQLException {
		try {
			return rmiResultSet_.getTimestamp(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column value can be retrieved as a stream of ASCII characters and then
	 * read in chunks from the stream. This method is particularly suitable for
	 * retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into ASCII.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream. . Also, a stream may return 0 for
	 * available() whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of one byte ASCII characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// TBD There's a hack there (InputStream not serializable)
	public java.io.InputStream getAsciiStream(int columnIndex)
			throws java.sql.SQLException {
		try {
			byte[] val = rmiResultSet_.getAsciiStream(columnIndex);
			if (val == null)
				return null;
			return new java.io.ByteArrayInputStream(val);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column value can be retrieved as a stream of Unicode characters and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into Unicode.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream. . Also, a stream may return 0 for
	 * available() whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of two byte Unicode characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// TBD There's a hack there (InputStream not serializable)
	public java.io.InputStream getUnicodeStream(int columnIndex)
			throws java.sql.SQLException {
		try {
			byte[] val = rmiResultSet_.getUnicodeStream(columnIndex);
			if (val == null)
				return null;
			return new java.io.ByteArrayInputStream(val);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column value can be retrieved as a stream of uninterpreted bytes and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARBINARY values.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream. Also, a stream may return 0 for available()
	 * whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of uninterpreted bytes. If the value is SQL NULL then the
	 *         result is null.
	 */
	// TBD There's a hack there (InputStream not serializable)
	public java.io.InputStream getBinaryStream(int columnIndex)
			throws java.sql.SQLException {
		try {
			byte[] val = rmiResultSet_.getBinaryStream(columnIndex);
			if (val == null)
				return null;
			return new java.io.ByteArrayInputStream(val);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// ======================================================================
	// Methods for accessing results by column name
	// ======================================================================

	/**
	 * Get the value of a column in the current row as a Java String.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public String getString(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getString(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java boolean.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is false
	 */
	public boolean getBoolean(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getBoolean(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java byte.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public byte getByte(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getByte(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java short.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public short getShort(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getShort(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java int.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public int getInt(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getInt(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java long.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public long getLong(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getLong(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java float.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public float getFloat(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getFloat(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java double.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 */
	public double getDouble(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getDouble(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.lang.BigDecimal
	 * object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @param scale
	 *            the number of digits to the right of the decimal
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public BigDecimal getBigDecimal(String columnName, int scale)
			throws java.sql.SQLException {
		try {
			return rmiResultSet_.getBigDecimal(columnName, scale);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a Java byte array. The
	 * bytes represent the raw values returned by the driver.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public byte[] getBytes(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getBytes(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Date object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Date getDate(String columnName)
			throws java.sql.SQLException {
		try {
			return rmiResultSet_.getDate(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Time object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Time getTime(String columnName)
			throws java.sql.SQLException {
		try {
			return rmiResultSet_.getTime(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Timestamp
	 * object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 */
	public java.sql.Timestamp getTimestamp(String columnName)
			throws java.sql.SQLException {
		try {
			return rmiResultSet_.getTimestamp(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column value can be retrieved as a stream of ASCII characters and then
	 * read in chunks from the stream. This method is particularly suitable for
	 * retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into ASCII.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of one byte ASCII characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// TBD There's a hack there (InputStream not serializable)
	public java.io.InputStream getAsciiStream(String columnName)
			throws java.sql.SQLException {
		try {
			byte[] val = rmiResultSet_.getAsciiStream(columnName);
			if (val == null)
				return null;
			return new java.io.ByteArrayInputStream(val);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column value can be retrieved as a stream of Unicode characters and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARCHAR values. The JDBC driver will do any
	 * necessary conversion from the database format into Unicode.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of two byte Unicode characters. If the value is SQL NULL
	 *         then the result is null.
	 */
	// TBD There's a hack there (InputStream not serializable)
	public java.io.InputStream getUnicodeStream(String columnName)
			throws java.sql.SQLException {
		try {
			byte[] val = rmiResultSet_.getUnicodeStream(columnName);
			if (val == null)
				return null;
			return new java.io.ByteArrayInputStream(val);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * A column value can be retrieved as a stream of uninterpreted bytes and
	 * then read in chunks from the stream. This method is particularly suitable
	 * for retrieving large LONGVARBINARY values.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to
	 * getting the value of any other column. The next call to a get method
	 * implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a
	 *         stream of uninterpreted bytes. If the value is SQL NULL then the
	 *         result is null.
	 */
	// TBD There's a hack there (InputStream not serializable)
	public java.io.InputStream getBinaryStream(String columnName)
			throws java.sql.SQLException {
		try {
			byte[] val = rmiResultSet_.getBinaryStream(columnName);
			if (val == null)
				return null;
			return new java.io.ByteArrayInputStream(val);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// =====================================================================
	// Advanced features:
	// =====================================================================

	/**
	 * <p>
	 * The first warning reported by calls on this ResultSet is returned.
	 * Subsequent ResultSet warnings will be chained to this SQLWarning.
	 * 
	 * <P>
	 * The warning chain is automatically cleared each time a new row is read.
	 * 
	 * <P>
	 * <B>Note:</B> This warning chain only covers warnings caused by ResultSet
	 * methods. Any warning caused by statement methods (such as reading OUT
	 * parameters) will be chained on the Statement object.
	 * 
	 * @return the first SQLWarning or null
	 */
	public SQLWarning getWarnings() throws java.sql.SQLException {
		try {
			return rmiResultSet_.getWarnings();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * After this call getWarnings returns null until a new warning is reported
	 * for this ResultSet.
	 */
	public void clearWarnings() throws java.sql.SQLException {
		try {
			rmiResultSet_.clearWarnings();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * Get the name of the SQL cursor used by this ResultSet.
	 * 
	 * <P>
	 * In SQL, a result table is retrieved through a cursor that is named. The
	 * current row of a result can be updated or deleted using a positioned
	 * update/delete statement that references the cursor name.
	 * 
	 * <P>
	 * JDBC supports this SQL feature by providing the name of the SQL cursor
	 * used by a ResultSet. The current row of a ResultSet is also the current
	 * row of this SQL cursor.
	 * 
	 * <P>
	 * <B>Note:</B> If positioned update is not supported a
	 * java.sql.SQLException is thrown
	 * 
	 * @return the ResultSet's SQL cursor name
	 */
	public String getCursorName() throws java.sql.SQLException {
		try {
			return rmiResultSet_.getCursorName();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * The number, types and properties of a ResultSet's columns are provided by
	 * the getMetaData method.
	 * 
	 * @return the description of a ResultSet's columns
	 */
	public java.sql.ResultSetMetaData getMetaData()
			throws java.sql.SQLException {
		try {
			return new RJResultSetMetaData(rmiResultSet_.getMetaData());
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * <p>
	 * Get the value of a column in the current row as a Java object.
	 * 
	 * <p>
	 * This method will return the value of the given column as a Java object.
	 * The type of the Java object will be the default Java Object type
	 * corresponding to the column's SQL type, following the mapping specified
	 * in the JDBC spec.
	 * 
	 * <p>
	 * This method may also be used to read datatabase specific abstract data
	 * types.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return A java.lang.Object holding the column value.
	 */
	public Object getObject(int columnIndex) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getObject(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	/**
	 * <p>
	 * Get the value of a column in the current row as a Java object.
	 * 
	 * <p>
	 * This method will return the value of the given column as a Java object.
	 * The type of the Java object will be the default Java Object type
	 * corresponding to the column's SQL type, following the mapping specified
	 * in the JDBC spec.
	 * 
	 * <p>
	 * This method may also be used to read datatabase specific abstract data
	 * types.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return A java.lang.Object holding the column value.
	 */
	public Object getObject(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.getObject(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// ----------------------------------------------------------------

	/**
	 * Map a Resultset column name to a ResultSet column index.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @return the column index
	 */
	public int findColumn(String columnName) throws java.sql.SQLException {
		try {
			return rmiResultSet_.findColumn(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// JDBC 2.0 methods
	// added by Mike Jennings sometime in the
	// summer of 1999
	// remove comments to compile for JDBC 2.0

	// Implementation added Aug 2000 by Peter Hearty (peter.hearty@lutris.com).
	public void updateTimestamp(String columnName, Timestamp x)
			throws SQLException {
		try {
			rmiResultSet_.updateTimestamp(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateTimestamp(int columnIndex, Timestamp x)
			throws SQLException {
		try {
			rmiResultSet_.updateTimestamp(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateTime(String columnName, Time x) throws SQLException {
		try {
			rmiResultSet_.updateTime(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateTime(int columnIndex, Time x) throws SQLException {
		try {
			rmiResultSet_.updateTime(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateString(String columnName, String x) throws SQLException {
		try {
			rmiResultSet_.updateString(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateString(int columnIndex, String x) throws SQLException {
		try {
			rmiResultSet_.updateString(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateShort(int columnIndex, short x) throws SQLException {
		try {
			rmiResultSet_.updateShort(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateShort(String columnName, short x) throws SQLException {
		try {
			rmiResultSet_.updateShort(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateRow() throws SQLException {
		try {
			rmiResultSet_.updateRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateObject(String columnName, Object x, int scale)
			throws SQLException {
		try {
			rmiResultSet_.updateObject(columnName, x, scale);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateObject(String columnName, Object x) throws SQLException {
		try {
			rmiResultSet_.updateObject(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateObject(int columnIndex, Object x, int scale)
			throws SQLException {
		try {
			rmiResultSet_.updateObject(columnIndex, x, scale);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateObject(int columnIndex, Object x) throws SQLException {
		try {
			rmiResultSet_.updateObject(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateNull(String columnName) throws SQLException {
		try {
			rmiResultSet_.updateNull(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateNull(int columnIndex) throws SQLException {
		try {
			rmiResultSet_.updateNull(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateLong(String columnName, long x) throws SQLException {
		try {
			rmiResultSet_.updateLong(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateLong(int columnIndex, long x) throws SQLException {
		try {
			rmiResultSet_.updateLong(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateInt(String columnName, int x) throws SQLException {
		try {
			rmiResultSet_.updateInt(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateInt(int columnIndex, int x) throws SQLException {
		try {
			rmiResultSet_.updateInt(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateFloat(String columnName, float x) throws SQLException {
		try {
			rmiResultSet_.updateFloat(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateFloat(int columnIndex, float x) throws SQLException {
		try {
			rmiResultSet_.updateFloat(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateDouble(String columnName, double x) throws SQLException {
		try {
			rmiResultSet_.updateDouble(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateDouble(int columnIndex, double x) throws SQLException {
		try {
			rmiResultSet_.updateDouble(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateDate(String columnName, Date x) throws SQLException {
		try {
			rmiResultSet_.updateDate(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateDate(int columnIndex, Date x) throws SQLException {
		try {
			rmiResultSet_.updateDate(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateCharacterStream(String columnName, java.io.Reader reader,
			int length) throws SQLException {
		try {
			rmiResultSet_.updateCharacterStream(columnName, reader, length);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateCharacterStream(int columnIndex, java.io.Reader x,
			int length) throws SQLException {
		try {
			rmiResultSet_.updateCharacterStream(columnIndex, x, length);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBytes(String columnName, byte[] x) throws SQLException {
		try {
			rmiResultSet_.updateBytes(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		try {
			rmiResultSet_.updateBytes(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateByte(String columnName, byte x) throws SQLException {
		try {
			rmiResultSet_.updateByte(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateByte(int columnIndex, byte x) throws SQLException {
		try {
			rmiResultSet_.updateByte(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBoolean(String columnName, boolean x) throws SQLException {
		try {
			rmiResultSet_.updateBoolean(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		try {
			rmiResultSet_.updateBoolean(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBinaryStream(String columnName, java.io.InputStream x,
			int length) throws SQLException {
		try {
			rmiResultSet_.updateBinaryStream(columnName, x, length);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBinaryStream(int columnIndex, java.io.InputStream x,
			int length) throws SQLException {
		try {
			rmiResultSet_.updateBinaryStream(columnIndex, x, length);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBigDecimal(String columnName, BigDecimal x)
			throws SQLException {
		try {
			rmiResultSet_.updateBigDecimal(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws SQLException {
		try {
			rmiResultSet_.updateBigDecimal(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateAsciiStream(String columnName, java.io.InputStream x,
			int length) throws SQLException {
		try {
			rmiResultSet_.updateAsciiStream(columnName, x, length);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateAsciiStream(int columnIndex, java.io.InputStream x,
			int length) throws SQLException {
		try {
			rmiResultSet_.updateAsciiStream(columnIndex, x, length);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void setFetchSize(int rows) throws SQLException {
		try {
			rmiResultSet_.setFetchSize(rows);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void setFetchDirection(int direction) throws SQLException {
		try {
			rmiResultSet_.setFetchDirection(direction);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean rowUpdated() throws SQLException {
		try {
			return rmiResultSet_.rowUpdated();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean rowInserted() throws SQLException {
		try {
			return rmiResultSet_.rowInserted();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean rowDeleted() throws SQLException {
		try {
			return rmiResultSet_.rowDeleted();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean relative(int rows) throws SQLException {
		try {
			return rmiResultSet_.relative(rows);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void refreshRow() throws SQLException {
		try {
			rmiResultSet_.refreshRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean previous() throws SQLException {
		try {
			return rmiResultSet_.previous();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void moveToInsertRow() throws SQLException {
		try {
			rmiResultSet_.moveToInsertRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void moveToCurrentRow() throws SQLException {
		try {
			rmiResultSet_.moveToCurrentRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean last() throws SQLException {
		try {
			return rmiResultSet_.last();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean isLast() throws SQLException {
		try {
			return rmiResultSet_.isLast();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean isFirst() throws SQLException {
		try {
			return rmiResultSet_.isFirst();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean isBeforeFirst() throws SQLException {
		try {
			return rmiResultSet_.isBeforeFirst();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean isAfterLast() throws SQLException {
		try {
			return rmiResultSet_.isAfterLast();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void insertRow() throws SQLException {
		try {
			rmiResultSet_.insertRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getType() throws SQLException {
		try {
			return rmiResultSet_.getType();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Timestamp getTimestamp(String columnName, java.util.Calendar cal)
			throws SQLException {
		try {
			return rmiResultSet_.getTimestamp(columnName, cal);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Timestamp getTimestamp(int columnIndex, java.util.Calendar cal)
			throws SQLException {
		try {
			return rmiResultSet_.getTimestamp(columnIndex, cal);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Time getTime(String columnName, java.util.Calendar cal)
			throws SQLException {
		try {
			return rmiResultSet_.getTime(columnName, cal);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Time getTime(int columnIndex, java.util.Calendar cal)
			throws SQLException {
		try {
			return rmiResultSet_.getTime(columnIndex, cal);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Statement getStatement() throws SQLException {
		return statement_;
	}

	public Ref getRef(String colName) throws SQLException {
		try {
			return new RJRef(rmiResultSet_.getRef(colName));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Ref getRef(int i) throws SQLException {
		try {
			return new RJRef(rmiResultSet_.getRef(i));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getFetchSize() throws SQLException {
		try {
			return rmiResultSet_.getFetchSize();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getFetchDirection() throws SQLException {
		try {
			return rmiResultSet_.getFetchDirection();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Date getDate(String columnName, java.util.Calendar cal)
			throws SQLException {
		try {
			return rmiResultSet_.getDate(columnName, cal);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Date getDate(int columnIndex, java.util.Calendar cal)
			throws SQLException {
		try {
			return rmiResultSet_.getDate(columnIndex, cal);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getConcurrency() throws SQLException {
		try {
			return rmiResultSet_.getConcurrency();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Clob getClob(String colName) throws SQLException {
		try {
			return new RJClob(rmiResultSet_.getClob(colName));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Clob getClob(int i) throws SQLException {
		try {
			return new RJClob(rmiResultSet_.getClob(i));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public java.io.Reader getCharacterStream(String columnName)
			throws SQLException {
		try {
			return rmiResultSet_.getCharacterStream(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public java.io.Reader getCharacterStream(int columnIndex)
			throws SQLException {
		try {
			return rmiResultSet_.getCharacterStream(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Blob getBlob(String colName) throws SQLException {
		try {
			return new RJBlob(rmiResultSet_.getBlob(colName));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Blob getBlob(int i) throws SQLException {
		try {
			return new RJBlob(rmiResultSet_.getBlob(i));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public BigDecimal getBigDecimal(String columnName) throws SQLException {
		try {
			return rmiResultSet_.getBigDecimal(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		try {
			return rmiResultSet_.getBigDecimal(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Array getArray(String colName) throws SQLException {
		try {
			return new RJArray(rmiResultSet_.getArray(colName));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public Array getArray(int i) throws SQLException {
		try {
			return new RJArray(rmiResultSet_.getArray(i));
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean first() throws SQLException {
		try {
			return rmiResultSet_.first();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void cancelRowUpdates() throws SQLException {
		try {
			rmiResultSet_.cancelRowUpdates();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void deleteRow() throws SQLException {
		try {
			rmiResultSet_.deleteRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void beforeFirst() throws SQLException {
		try {
			rmiResultSet_.beforeFirst();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void afterLast() throws SQLException {
		try {
			rmiResultSet_.afterLast();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public boolean absolute(int row) throws SQLException {
		try {
			return rmiResultSet_.absolute(row);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public int getRow() throws SQLException {
		try {
			return rmiResultSet_.getRow();
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	// -------------------------- JDBC 3.0
	// ----------------------------------------

	public java.net.URL getURL(int columnIndex) throws SQLException {
		try {
			return rmiResultSet_.getURL(columnIndex);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public java.net.URL getURL(String columnName) throws SQLException {
		try {
			return rmiResultSet_.getURL(columnName);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateRef(int columnIndex, java.sql.Ref x) throws SQLException {
		try {
			rmiResultSet_.updateRef(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateRef(String columnName, java.sql.Ref x)
			throws SQLException {
		try {
			rmiResultSet_.updateRef(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBlob(int columnIndex, java.sql.Blob x)
			throws SQLException {
		try {
			rmiResultSet_.updateBlob(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateBlob(String columnName, java.sql.Blob x)
			throws SQLException {
		try {
			rmiResultSet_.updateBlob(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateClob(int columnIndex, java.sql.Clob x)
			throws SQLException {
		try {
			rmiResultSet_.updateClob(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateClob(String columnName, java.sql.Clob x)
			throws SQLException {
		try {
			rmiResultSet_.updateClob(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateArray(int columnIndex, java.sql.Array x)
			throws SQLException {
		try {
			rmiResultSet_.updateArray(columnIndex, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	public void updateArray(String columnName, java.sql.Array x)
			throws SQLException {
		try {
			rmiResultSet_.updateArray(columnName, x);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Object getObject(int columnIndex, Map<String, Class<?>> map)throws SQLException {
		try {
			return rmiResultSet_.getObject(columnIndex, map);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	@Override
	public Object getObject(String columnLabel, Map<String, Class<?>> map) throws SQLException {
		try {
			return rmiResultSet_.getObject(columnLabel, map);
		} catch (RemoteException e) {
			throw new java.sql.SQLException(e.getMessage());
		}
	}

	@Override
	public RowId getRowId(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public RowId getRowId(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public int getHoldability() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public NClob getNClob(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public NClob getNClob(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void updateSQLXML(int columnIndex, SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateSQLXML(String columnLabel, SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public String getNString(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getNString(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x,
			long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream,
			long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateClob(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void updateNClob(String columnLabel, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

};
